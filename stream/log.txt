Клиент-серверная модель (client-server model) описывает отношение меж-ду двумя компьютерными программами, в котором одна программа – клиент – выполняет запросы к другой программе – серверу. Эта модель решает, в основном, задачу развёртывания приложения. С использованием клиент-серверной модели созданы многие приложения для работы с базами данных, электронной почтой и для доступа к веб-ресурсам.
Перечислим основные принципы данного архитектурного стиля:
1. Клиент инициирует один или несколько запросов, ожидает ответа на них, а затем обрабатывает ответы.
2. В определённый момент времени клиент подключён к одному серверу для обработки запросов (реже – к небольшой группе серверов).
3. Клиент работает с пользователем напрямую, применяя графический интерфейс.
4. Сервер не инициирует запросов.
5. Обычно для выполнения запросов клиенты проходят аутентификацию на сервере.
Главными преимуществами клиент-серверной модели являются:
– Высокая безопасность. Все данные хранятся на сервере, обеспечивающем больший уровень безопасности, нежели отдельный клиент.
– Централизованный доступ к данным. Так как данные хранятся только на сервере, ими легко управлять (например, обеспечить обновление).
– Устойчивость и лёгкость сопровождения. Роль сервера могут выполнять несколько физических компьютеров, объединённых в сеть. Благодаря этому клиент не замечает сбоев или замены отдельного серверного компьютера.
Рассмотрим некоторые варианты клиент-серверной модели. В системах клиент-очередь-клиент (client-queue-client или passive queue) сервер исполняет роль очереди для данных клиентов. То есть, клиенты использую сервер только для обмена данными между собой. Пиринговые приложения (peer-to-peer application) – это вариация системы клиент-очередь-клиент, в которой любой клиент может играть роль сервера. Сервера приложений (application server) служат для размещения и выполнения программ, которыми управляет клиент.
3. Компонентная архитектура
Ключевым понятием компонентной архитектуры является компонент (component). Это программный объект, спроектированный так, чтобы удовлетворять следующим требованиям:
1. Компонент допускает повторное использование в различных системах.
2. Компонент не хранит информации, специфичной для конкретного ПО, в котором он используется.
3. Допускается создание новых компонентов на основе существующих.
4. Компонент имеет известный интерфейс для взаимодействия, но скрывает детали своей внутренней реализации.
5. Компоненты проектируются так, чтобы иметь минимальные зависимо-сти от других компонентов.
Типичным примером компонентов являются элементы пользовательского интерфейса (элементы управления).
Компонентная архитектура сосредоточена на выделении отдельных ком-понентов и организации взаимодействия между ними. Этот стиль решает задачи структурирования приложений и обеспечивает следующие преимущества:
– Лёгкость развёртывания. Когда для компонента доступна новая вер-сия, старая версия заменяется без влияния на остальные компоненты.
– Уменьшение стоимости. При разработке можно применять готовые компоненты сторонних производителей.
– Повторное использование. Одни и те же компоненты могут использо-ваться в нескольких приложениях.
– Уменьшение технической сложности. Обычно компоненты, состав-ляющие одно приложение, развёрнуты в рамках одного программного контейнера. Этот контейнер управляет временем жизни компонентов, активацией компонентов, передачей сообщений между компонентами и так далее.
4. Многоуровневая архитектура
Многоуровневая архитектура (multilayered architecture) сосредоточена на иерархическом распределении отдельных частей системы при помощи эффективного разделения отношений. Каждая часть соотносится с определённым уровнем (layer), для каждого уровня заданы выполняемые им функции, уровни выстроены в стековую структуру (то есть находятся один поверх другого). Например, типичная многоуровневая архитектура веб-приложения включает уровень представления (компоненты пользовательского интерфейса), уровень бизнес-логики (обработка данных) и уровень доступа к данным. При этом уровень представления считается высшим, за ним идёт уровень бизнес-логики, а за уровнем бизнес-логики – уровень доступа к данным.
Сформулируем основные принципы многоуровневой архитектуры:
1. Проектирование чётко устанавливает разграничение функций между уровнями.
2. Нижние уровни независимы от верхних уровней.
3. Верхние уровни вызывают функции нижних уровней, но при этом взаимодействуют только соседние уровни иерархии.
Использование многоуровневой архитектуры обеспечивает следующие преимущества:
– Изоляция. Разработка и обновление ПО могут быть изолированы рамками одного уровня.
– Производительность. Распределение уровней на отдельные физические компьютеры повышает производительность и отказоустойчивость.
– Тестируемость. Уровни допускают независимое тестирование.
Многоуровневая архитектура активно применяется при создании бизнес-приложений и сайтов, особенно приложений масштаба предприятия. При этом обычно используется следующий набор уровней (рис. 1):
Уровень представления (presentation layer) ответственен за взаимодействие с пользователем, ввод и вывод информации.
Бизнес-уровень или уровень бизнес-логики (business logic layer) обрабатывает информацию, реализуя конкретные бизнес-правила.
Уровень доступа к данным (data access layer) обеспечивает загрузку и сохранение информации, используя источник данных (файл, база данных) или внешний сервис.
 
Рис. 1. Типичные уровни бизнес-приложения.
Для каждого уровня дополнительно можно выделить типичный набор компонентов (рис. 2). Заметим, что не все из перечисленных компонентов (и даже уровней) должны присутствовать в любом бизнес-приложении .
 
Рис. 2. Компоненты отдельных уровней.
1. Компоненты пользовательского интерфейса (UI Components). Они предназначены для вывода информации и для ввода данных пользователями. Эти компоненты являются элементами оконного или веб-интерфейса.
2. Компоненты сценариев (UI Process Components). Обычно система подчиняется определённым правилам взаимодействия с ней. Например, в приложении для продажи товаров реализуется следующий сценарий: пользователь выбирает категорию товара из списка категорий, система показывает список товаров, затем пользователь выбирает товар, и система показывает данные по товару. Для того чтобы упорядочить такие сценарии и повторно их использовать, они объединяются в специальные объекты. Кроме этого, создаётся специальный механизм, который позволяет пользователю работать с системой только по определённым сценариям.
3. Рабочие потоки (Business Workflows). После получения данных от пользователя они должны быть использованы при выполнении бизнес-процессов (рабочих потоков). Бизнес-процессы состоят из шагов, которые должны быть выполнены в определённом порядке. Например, система должна подсчитать общую сумму заказа, проверить данные кредитной карты и организовать доставку товара. При этом заранее неизвестно, сколько времени потребуется на выполнение этих шагов. Поэтому нужен механизм управления этими операциями.
